<!DOCTYPE html>
<html>
	<head>

		<meta name="keywords" content="WebRTC, HTML5, JavaScript" />
		<meta name="description" content="WebRTC Reference App" />
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1">

		<title>WebRTC client</title>

	</head>

	<body>


		<script src="/socket.io/socket.io.js"></script>

		<div id = 'videos'>
		</div>


		<script>
			// Init socket
			var socket = io();
			
			// Keep track of users
			var localUser = {id : "", mediaStream : ""};

			// Init getUserMedia
			navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
			// Init peerConnection
			var peerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
			// Init sessionDescription
			var sessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
			

			// Initialize some config variables
			var config = {"iceServers":[{"url":"stun:stun.l.google.com:19302"}]};
			var connection = { 'optional': [{'DtlsSrtpKeyAgreement': true}, {'RtpDataChannels': true }] };

			// Temp var to keep video
			var video = null;
			
			// Create a peer connection
			pc = new webkitRTCPeerConnection(config, connection);
			console.log('Created a peer connection');

			pc.onicecandidate = function(e)
										{
											console.log('Got ICE candidate');
											if (!peerConnection || !e || !e.candidate) 
												return;
											var candidate = event.candidate;
											sendNegotiation("icecandidate", candidate);
										};
	
			pc.createOffer = function(offerSDP) 
									{
							  			pc.setLocalDescription(offerSDP);
							  			socket.send({targetUser: 'target-user-id', offerSDP: offerSDP});
							  		};
			// Open data channel
			dataChannel = pc.createDataChannel("datachannel", {reliable: false});
			
			// Message callback
			dataChannel.onmessage = function(e)
											{
												console.log("DC from ["+user2+"]:" +e.data);
											};

			// Data channel opened callback
			dataChannel.onopen = function()
										{
											console.log("------ DATACHANNEL OPENED ------");
										};
		
			// Data channel closed callback	
			dataChannel.onclose = function()
											{
														console.log("------ DC closed! ------");
											};
			// Data channel error callback
			dataChannel.onerror = function()
											{
												console.log("DC ERROR!!!");
											};

			socket.on('dataIncoming', 
							function(id)
							{
								video = document.getElementById('video' + id);			
								console.log('Grabbed video' + id);		     				
							});

			pc.onaddstream = function(stream)
									{
										console.log('Received remote media, displaying');
										// Find video
										var v = video;
										// Attach data
										v.src = window.URL.createObjectURL(stream);
										// Play video
										v.play();
						       	};
			// Data channel callback
			pc.ondatachannel = function() 
										{
											console.log('peerConnection.ondatachannel event fired.');
										};
			
			// Set remote description
			//pc.setRemoteDescription(new RTCSessionDescription(offer));

			var sdpConstraints = {'mandatory':
												{
													'OfferToReceiveAudio': true,
													'OfferToReceiveVideo': true
												}
					     				};
			// Create and send answer sdp
			pc.createAnswer(function(sdp) 
				    		   	{
						  				peerConnection.setLocalDescription(sdp);
						  				sendNegotiation("answer", sdp);
						  				console.log("------ SEND ANSWER ------");
						    		}, null, sdpConstraints);

			// Proccess ice candidates
			function processIce(iceCandidate)
			{
  				peerConnection.addIceCandidate(new RTCIceCandidate(iceCandidate));
			}

			// Helper functions
			function end()
			{
				console.log('Ending call');
				// Find all the videos
				var vids = document.getElementsByTagName("video");
				// Loop through and pause each video
				for(index = 0; index < vids.length; i++)
					vids[index].pause();
				// Terminate the connection
				pc.close();
			}

			// Error
			function error(e)
			{
				// Log the error
				console.log("Error: " + e);
				// Crash
				end();
			}
		
			// Prepare constraints
			var constraints = {video: true, audio: true};

			// Send video function
			function gotMedia(stream)
			{
				console.log('Got media, adding stream');
				// Add the stream
				pc.addStream(stream);
			}
			
			// Error function
			function gotError(error)
			{
				// Log error
				console.log("navigator.getUserMedia error : ", error);
			}

			

			// User updates
			socket.on('someoneLeft', 
							function(users)
							{
								console.log('A user has left');
								// Find the div
								var place = document.getElementById('videos');
								// Query videos
								var vids = place.childNodes;

								// Delete inactive video elements
								for(index = 1; index <= vids.length; index ++)
								{
									// Check against active user ids
									var vidFound = false;
									for(uIndex = 0; uIndex < users.length; uIndex ++)
									{
										if(vids[index].id == users[index].id)
											vidFound = true;
									}
									// Remove video element
									if(!vidFound)
										place.removeChild(vids[index]);
								}
							});
			
			socket.on('newUser', 
							function(newNumUsers)
							{
								console.log('New user: ' + newNumUsers);
								// Find the div
								var place = document.getElementById('videos');
								// Create a new video element
								var v = document.createElement('video');
								v.autoPlay = true;
								v.src = "";
								v.id = 'video' + newNumUsers;
								// Update localUser id
								localUser.id = v.id;
								// Add video to the div
								place.appendChild(v);
							
							});
			// Begin the process
			navigator.getUserMedia(constraints, gotMedia, gotError);
	
			
			
		</script>

	</body>
</html>
